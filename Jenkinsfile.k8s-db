pipeline {
    agent any
    
    tools {
        // Configura kubectl en Jenkins o usa el del sistema
        kubectl 'kubectl' // Asegúrate de tener kubectl instalado en Jenkins
    }
    
    environment {
        // Apunta al cluster de minikube
        KUBECONFIG = "${env.HOME}/.kube/config"
    }
    
    stages {
        stage('Check Cluster Access') {
            steps {
                script {
                    sh 'kubectl cluster-info'
                    sh 'kubectl get nodes'
                }
            }
        }
        
        stage('Deploy MySQL Resources') {
            steps {
                script {
                    echo 'Aplicando configuración de MySQL...'
                    
                    sh '''
                        kubectl apply -f mysql-secret.yaml
                        kubectl apply -f mysql-configmap.yaml
                        kubectl apply -f mysql-pvc.yaml
                        kubectl apply -f mysql-deployment.yaml
                        kubectl apply -f mysql-service.yaml
                    '''
                }
            }
        }
        
        stage('Wait for MySQL') {
            steps {
                script {
                    timeout(time: 10, unit: 'MINUTES') {
                        waitUntil {
                            try {
                                def podName = sh(
                                    script: 'kubectl get pods -l app=mysql -o jsonpath="{.items[0].metadata.name}"',
                                    returnStdout: true
                                ).trim()
                                
                                def status = sh(
                                    script: "kubectl get pod ${podName} -o jsonpath='{.status.phase}'",
                                    returnStdout: true
                                ).trim()
                                
                                def ready = sh(
                                    script: "kubectl get pod ${podName} -o jsonpath='{.status.containerStatuses[0].ready}'",
                                    returnStdout: true
                                ).trim()
                                
                                echo "Pod: ${podName}, Status: ${status}, Ready: ${ready}"
                                return status == "Running" && ready == "true"
                            } catch (Exception e) {
                                echo "Esperando que MySQL esté listo..."
                                sleep 10
                                return false
                            }
                        }
                    }
                }
            }
        }
        
        stage('Final Verification') {
            steps {
                script {
                    sh '''
                        echo "=== Estado final ==="
                        kubectl get all -l app=mysql
                        kubectl get pvc
                        kubectl get configmap
                        kubectl get secret
                    '''
                }
            }
        }
    }
    
    post {
        always {
            echo "Pipeline ${currentBuild.result ?: 'SUCCESS'} - Completado"
        }
        success {
            echo '✅ MySQL desplegado exitosamente en Minikube!'
        }
        failure {
            echo '❌ Error en el despliegue'
            sh 'kubectl get events --sort-by=.lastTimestamp | tail -10'
        }
    }
}